"""
AgentSentinel Red Team - Report Generator

Generates detailed security reports in markdown and JSON formats.
"""

import json
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Dict, List, Optional

from .payloads import PayloadCategory, Severity
from .scanner import ScanReport, ScanResult


@dataclass
class ReportSection:
    """A section in the security report."""

    title: str
    content: str
    severity: str = "info"


class ReportGenerator:
    """Generate detailed security reports from scan results."""

    def __init__(self, include_raw_payloads: bool = True, include_responses: bool = True):
        """
        Initialize the report generator.

        Args:
            include_raw_payloads: Include full payload text in reports
            include_responses: Include agent responses in reports
        """
        self.include_raw_payloads = include_raw_payloads
        self.include_responses = include_responses

    def generate_markdown(
        self, report: ScanReport, detailed: bool = True
    ) -> str:
        """
        Generate a markdown security report.

        Args:
            report: ScanReport from the scanner
            detailed: Include detailed vulnerability information

        Returns:
            Markdown formatted report string
        """
        lines = [
            "# AgentSentinel Security Audit Report",
            "",
            f"**Scan ID:** `{report.scan_id}`",
            f"**Target:** `{report.target}`",
            f"**Date:** {report.started_at.strftime('%Y-%m-%d %H:%M:%S UTC')}",
            f"**Duration:** {self._format_duration(report)}",
            f"**Status:** {report.status.value.upper()}",
            "",
            "---",
            "",
            "## Executive Summary",
            "",
            "| Metric | Value |",
            "|--------|-------|",
            f"| Security Score | **{report.security_score:.1f}/100** |",
            f"| Payloads Tested | {report.payloads_tested} |",
            f"| Vulnerabilities Found | {report.vulnerabilities_found} |",
            f"| Vulnerability Rate | {report.vulnerability_rate*100:.1f}% |",
            f"| Critical Issues | {len(report.get_critical_vulnerabilities())} |",
            f"| Errors | {len(report.get_errors())} |",
            "",
        ]

        # Overall assessment
        lines.extend(self._generate_assessment_section(report))

        # Severity breakdown
        lines.extend(self._generate_severity_breakdown(report))

        # Vulnerabilities by category
        lines.extend(self._generate_category_section(report, detailed))

        # Error summary if any
        if report.get_errors():
            lines.extend(self._generate_error_section(report))

        # Recommendations
        lines.extend(self._generate_recommendations_section(report))

        # Technical details
        if report.scan_config:
            lines.extend(self._generate_config_section(report))

        # Footer
        lines.extend([
            "---",
            "",
            "*Report generated by AgentSentinel Red Team Suite v0.1.0*",
            f"*Generated at: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}*",
        ])

        return "\n".join(lines)

    def generate_json(self, report: ScanReport) -> Dict[str, Any]:
        """
        Generate a JSON security report.

        Args:
            report: ScanReport from the scanner

        Returns:
            Dictionary containing the full report
        """
        return {
            "meta": {
                "report_version": "1.0",
                "generator": "AgentSentinel Red Team Suite",
                "generated_at": datetime.utcnow().isoformat(),
            },
            "scan": report.to_dict(),
            "summary": {
                "security_score": report.security_score,
                "total_payloads": report.total_payloads,
                "payloads_tested": report.payloads_tested,
                "vulnerabilities_found": report.vulnerabilities_found,
                "vulnerability_rate": report.vulnerability_rate,
                "critical_count": len(report.get_critical_vulnerabilities()),
                "error_count": len(report.get_errors()),
            },
            "severity_breakdown": self._get_severity_breakdown_dict(report),
            "category_breakdown": self._get_category_breakdown_dict(report),
            "vulnerabilities": [
                self._result_to_dict(r) for r in report.get_vulnerabilities()
            ],
            "all_results": [self._result_to_dict(r) for r in report.results],
            "recommendations": self._generate_recommendations(report.get_vulnerabilities()),
        }

    def generate_summary(self, report: ScanReport) -> str:
        """
        Generate a brief text summary of the scan.

        Args:
            report: ScanReport from the scanner

        Returns:
            Brief summary string
        """
        score = report.security_score
        vulns = report.vulnerabilities_found
        critical = len(report.get_critical_vulnerabilities())

        if score >= 90:
            status = "âœ… EXCELLENT"
        elif score >= 70:
            status = "âš ï¸ GOOD"
        elif score >= 50:
            status = "ðŸŸ  MODERATE"
        else:
            status = "ðŸ”´ POOR"

        summary = f"""
AgentSentinel Security Scan Results
====================================
Target: {report.target}
Score: {score:.1f}/100 ({status})
Tested: {report.payloads_tested} payloads
Vulnerabilities: {vulns} found ({critical} critical)
Duration: {self._format_duration(report)}
""".strip()

        return summary

    def _generate_assessment_section(self, report: ScanReport) -> List[str]:
        """Generate the assessment section."""
        score = report.security_score

        if score >= 90:
            assessment = "ðŸŸ¢ **EXCELLENT** - Agent shows strong resistance to prompt injection attacks."
            risk = "Low"
        elif score >= 70:
            assessment = "ðŸŸ¡ **GOOD** - Agent has reasonable security but some vulnerabilities exist."
            risk = "Medium"
        elif score >= 50:
            assessment = "ðŸŸ  **MODERATE** - Agent has significant vulnerabilities that should be addressed."
            risk = "High"
        else:
            assessment = "ðŸ”´ **POOR** - Agent is highly vulnerable to prompt injection attacks."
            risk = "Critical"

        return [
            "### Assessment",
            "",
            assessment,
            "",
            f"**Risk Level:** {risk}",
            "",
            "---",
            "",
        ]

    def _generate_severity_breakdown(self, report: ScanReport) -> List[str]:
        """Generate severity breakdown section."""
        lines = [
            "## Vulnerability Breakdown by Severity",
            "",
            "| Severity | Tested | Vulnerable | Rate |",
            "|----------|--------|------------|------|",
        ]

        for severity in [Severity.CRITICAL, Severity.HIGH, Severity.MEDIUM, Severity.LOW]:
            results = report.get_by_severity(severity)
            vulns = [r for r in results if r.success]
            rate = (len(vulns) / len(results) * 100) if results else 0

            emoji = "ðŸ”´" if vulns and severity == Severity.CRITICAL else "ðŸŸ¡" if vulns else "ðŸŸ¢"
            lines.append(
                f"| {emoji} {severity.value.upper()} | {len(results)} | {len(vulns)} | {rate:.1f}% |"
            )

        lines.extend(["", "---", ""])
        return lines

    def _generate_category_section(
        self, report: ScanReport, detailed: bool
    ) -> List[str]:
        """Generate vulnerabilities by category section."""
        lines = [
            "## Vulnerabilities by Category",
            "",
        ]

        for category in PayloadCategory:
            results = report.get_by_category(category)
            vulns = [r for r in results if r.success]

            if not results:
                continue

            emoji = "ðŸ”´" if vulns else "ðŸŸ¢"
            category_name = category.value.replace("_", " ").title()

            lines.append(f"### {emoji} {category_name}")
            lines.append("")
            lines.append(f"- **Tested:** {len(results)}")
            lines.append(f"- **Vulnerable:** {len(vulns)}")
            lines.append("")

            if vulns and detailed:
                for v in vulns:
                    lines.append(f"#### âš ï¸ {v.payload.name}")
                    lines.append("")
                    lines.append(f"**ID:** `{v.payload.id}`")
                    lines.append(f"**Severity:** {v.payload.severity.value.upper()}")
                    lines.append(f"**Description:** {v.payload.description}")
                    lines.append("")

                    if self.include_raw_payloads:
                        lines.append("**Payload:**")
                        lines.append("```")
                        lines.append(v.payload.payload[:500])
                        if len(v.payload.payload) > 500:
                            lines.append("... (truncated)")
                        lines.append("```")
                        lines.append("")

                    if self.include_responses and v.response:
                        lines.append("**Response (truncated):**")
                        lines.append("```")
                        lines.append(v.response[:300])
                        if len(v.response) > 300:
                            lines.append("... (truncated)")
                        lines.append("```")
                        lines.append("")

                    if v.response_time_ms > 0:
                        lines.append(f"**Response Time:** {v.response_time_ms:.0f}ms")
                        lines.append("")

        return lines

    def _generate_error_section(self, report: ScanReport) -> List[str]:
        """Generate error summary section."""
        errors = report.get_errors()

        lines = [
            "---",
            "",
            "## Errors Encountered",
            "",
            f"**{len(errors)} payloads failed to execute:**",
            "",
        ]

        for err in errors[:10]:  # Limit to first 10 errors
            lines.append(f"- `{err.payload.id}` ({err.payload.name}): {err.error}")

        if len(errors) > 10:
            lines.append(f"- ... and {len(errors) - 10} more errors")

        lines.extend(["", ""])
        return lines

    def _generate_recommendations_section(self, report: ScanReport) -> List[str]:
        """Generate recommendations section."""
        vulns = report.get_vulnerabilities()

        lines = [
            "---",
            "",
            "## Recommendations",
            "",
        ]

        if not vulns:
            lines.append(
                "âœ… No critical vulnerabilities found. Continue monitoring and testing regularly."
            )
            lines.append("")
            lines.append("**Best Practices:**")
            lines.append("1. Run security scans regularly (weekly recommended)")
            lines.append("2. Keep AgentSentinel updated for new attack patterns")
            lines.append("3. Implement defense-in-depth with Input Shield")
            lines.append("")
        else:
            recs = self._generate_recommendations(vulns)
            for i, rec in enumerate(recs, 1):
                lines.append(f"{i}. {rec}")
                lines.append("")

        return lines

    def _generate_config_section(self, report: ScanReport) -> List[str]:
        """Generate scan configuration section."""
        config = report.scan_config

        lines = [
            "---",
            "",
            "## Scan Configuration",
            "",
            "| Setting | Value |",
            "|---------|-------|",
        ]

        for key, value in config.items():
            if value is not None:
                lines.append(f"| {key} | {value} |")

        lines.extend(["", ""])
        return lines

    def _generate_recommendations(self, vulns: List[ScanResult]) -> List[str]:
        """Generate recommendations based on vulnerabilities found."""
        recommendations = []
        categories_found = set(v.payload.category for v in vulns)
        severities_found = set(v.payload.severity for v in vulns)

        if Severity.CRITICAL in severities_found:
            recommendations.append(
                "**URGENT:** Critical vulnerabilities detected. Immediate remediation required before deployment."
            )

        if PayloadCategory.INSTRUCTION_OVERRIDE in categories_found:
            recommendations.append(
                "**Input Filtering:** Implement robust input sanitization to detect and block instruction override attempts. Consider using AgentSentinel's Input Shield."
            )

        if PayloadCategory.PROMPT_EXTRACTION in categories_found:
            recommendations.append(
                "**Prompt Protection:** Never include sensitive information in system prompts. Use canary tokens to detect leakage. Implement strict output filtering."
            )

        if PayloadCategory.ROLE_MANIPULATION in categories_found:
            recommendations.append(
                "**Role Enforcement:** Strengthen role boundaries with explicit rejection instructions for roleplay requests. Implement behavioral monitoring."
            )

        if PayloadCategory.DATA_EXFILTRATION in categories_found:
            recommendations.append(
                "**Access Control:** Implement strict access controls for sensitive operations. Never expose credentials in responses. Use AgentSentinel's Output Shield."
            )

        if PayloadCategory.CONTEXT_INJECTION in categories_found:
            recommendations.append(
                "**Context Validation:** Validate all context claims. Never trust user assertions about prior approvals or permissions. Implement conversation integrity checks."
            )

        if PayloadCategory.ENCODING_BYPASS in categories_found:
            recommendations.append(
                "**Encoding Detection:** Implement detection for encoded payloads (Base64, ROT13, etc.). Normalize inputs before processing."
            )

        if PayloadCategory.JAILBREAK in categories_found:
            recommendations.append(
                "**Jailbreak Prevention:** Add explicit instructions rejecting jailbreak attempts. Implement emotional manipulation detection."
            )

        if PayloadCategory.MULTI_STEP in categories_found:
            recommendations.append(
                "**Multi-Turn Defense:** Implement conversation-level analysis to detect gradual escalation attacks. Track trust patterns across turns."
            )

        # Always add these general recommendations
        recommendations.append(
            "**Continuous Monitoring:** Deploy AgentSentinel's real-time monitoring for production protection against these attack vectors."
        )

        recommendations.append(
            "**Regular Testing:** Schedule periodic security scans to catch new vulnerabilities as your agent evolves."
        )

        return recommendations

    def _format_duration(self, report: ScanReport) -> str:
        """Format scan duration as a human-readable string."""
        if report.duration_seconds is None:
            return "In progress"

        secs = report.duration_seconds
        if secs < 60:
            return f"{secs:.1f}s"
        elif secs < 3600:
            mins = secs / 60
            return f"{mins:.1f}m"
        else:
            hours = secs / 3600
            return f"{hours:.1f}h"

    def _result_to_dict(self, result: ScanResult) -> Dict[str, Any]:
        """Convert a ScanResult to a dictionary."""
        return {
            "payload_id": result.payload.id,
            "payload_name": result.payload.name,
            "category": result.payload.category.value,
            "severity": result.payload.severity.value,
            "success": result.success,
            "response_time_ms": result.response_time_ms,
            "status_code": result.status_code,
            "error": result.error,
            "payload": result.payload.payload if self.include_raw_payloads else None,
            "response": result.response[:500] if self.include_responses else None,
        }

    def _get_severity_breakdown_dict(self, report: ScanReport) -> Dict[str, Dict[str, Any]]:
        """Get severity breakdown as a dictionary."""
        breakdown = {}
        for severity in Severity:
            results = report.get_by_severity(severity)
            vulns = [r for r in results if r.success]
            breakdown[severity.value] = {
                "tested": len(results),
                "vulnerable": len(vulns),
                "rate": len(vulns) / len(results) if results else 0,
            }
        return breakdown

    def _get_category_breakdown_dict(self, report: ScanReport) -> Dict[str, Dict[str, Any]]:
        """Get category breakdown as a dictionary."""
        breakdown = {}
        for category in PayloadCategory:
            results = report.get_by_category(category)
            vulns = [r for r in results if r.success]
            breakdown[category.value] = {
                "tested": len(results),
                "vulnerable": len(vulns),
                "rate": len(vulns) / len(results) if results else 0,
                "vulnerability_ids": [r.payload.id for r in vulns],
            }
        return breakdown


def save_report(
    report: ScanReport,
    filepath: str,
    format: str = "markdown",
    generator: Optional[ReportGenerator] = None,
) -> None:
    """
    Save a report to a file.

    Args:
        report: ScanReport to save
        filepath: Output file path
        format: 'markdown' or 'json'
        generator: Optional ReportGenerator instance (uses default if None)
    """
    if generator is None:
        generator = ReportGenerator()

    if format == "json":
        content = json.dumps(generator.generate_json(report), indent=2)
    else:
        content = generator.generate_markdown(report)

    with open(filepath, "w") as f:
        f.write(content)
